from PyQt4.QtCore import QProcess, pyqtSignal, pyqtSlot, QObject, QRunnable, QThreadPool
import sys, Queue, time, traceback

class WorkerSignals(QObject):
    """
    Defines the signals available from a running worker thread.

    Supported signals are:

    finished
        No data

    error
        `tuple` (exctype, value, traceback.format_exc() )

    result
        `object` data returned from processing, anything

    progress
        `int` indicating % progress

    """
    finished = pyqtSignal(object, object)
    error = pyqtSignal(tuple)
    result = pyqtSignal(object)
    state = pyqtSignal(int)


class Worker(QRunnable):
    """
    Worker thread

    Inherits from QRunnable to handler worker thread setup, signals and wrap-up.
    finished
        No data

    error
        `tuple` (exctype, value, traceback.format_exc() )

    result
        `object` data returned from processing, anything

    progress
        `int` indicating % progress
    """
    def __init__(self):
        super(Worker, self).__init__()
        # Store constructor arguments (re-used for processing)
        self.signals = WorkerSignals()
        self.fn = None
        self.args = None
        self.kwargs = None
        self.setAutoDelete(False)

    def insert_function(self, fn, args):
        self.fn = fn
        self.args = args

    @pyqtSlot()
    def run(self):
        """ Initialise the runner function with passed args, kwargs."""
        # Retrieve args/kwargs here; and fire processing using them
        try:
            self.signals.state.emit(2)
            result = self.fn(*self.args)
        except:
            traceback.print_exc()
            exctype, value = sys.exc_info()[:2]
            self.signals.error.emit((exctype, value, traceback.format_exc()))
            # self.signals.state.emit(0)
        else:
            self.signals.result.emit(result)  # Return the result of the processing
        finally:
            exctype, value = sys.exc_info()[:2]
            self.signals.state.emit(0)
            self.signals.finished.emit(value, exctype)


class PROCESS(QObject):
    queue_finished = pyqtSignal(int)

    def __init__(self, parent=None):
        QObject.__init__(self, parent)
        self.process = QProcess()
        self.process.setProcessChannelMode(QProcess.MergedChannels)

        self.threadpool = QThreadPool()
        self.worker = Worker()
        self.queue = None

    def set_queue(self, queue):
        self.queue = queue

    def start_process(self):
        # self.worker = Worker()
        try:
            obj = self.queue.get(False)
            self.prog_name = obj.keys()[0]
            if callable(obj.values()[0][0]):
                funct = obj.values()[0][0]
                args = obj.values()[0][1]
                self.worker.insert_function(funct, args)
                self.threadpool.start(self.worker)
            else:
                print obj.keys()[0],obj.values()[0][0],obj.values()[0][1]
                self.process.start(obj.values()[0][0],obj.values()[0][1])
        except Queue.Empty:
            self.queue_finished.emit(self.queue.name)

    def force_finished(self):
        # for process (programs)
        self.process.terminate()
        if not self.process.waitForFinished(1000):
            self.process.kill()




